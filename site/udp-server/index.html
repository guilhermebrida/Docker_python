<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>UDP server - App Produção</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "UDP server";
        var mkdocs_page_input_path = "udp-server.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> App Produção
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Autoconfiguração dos Copilotos</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../XVM/">XVM</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../banco/">Banco de Dados</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../docker/">Docker</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">UDP server</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#le-as-variaveis-de-ambiente-do-dockerfile">Lê as variáveis de ambiente do dockerfile</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#conecta-ao-banco">Conecta ao banco</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#criacao-do-server-udp">Criação do Server UDP</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#classe-udp">Classe udp</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-handle_request">Função Handle_request</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-arquivos">Função Arquivos</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#envio-de-sfb">Envio de SFB</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-crc">Função crc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-criar">Função criar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-fdir">Função fdir</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#funcao-envioscript">Função envioScript</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#funcao-main">Função main</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#funcao-find">Função find</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#inicializacao-do-script">Inicialização do Script</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">App Produção</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>UDP server</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="udp-server">UDP server</h1>
<ul>
<li>Arquivo udp-server.py</li>
</ul>
<h2 id="le-as-variaveis-de-ambiente-do-dockerfile">Lê as variáveis de ambiente do dockerfile</h2>
<pre><code class="language-python">    postgres_host = os.environ['POSTGRES_HOST']
    postgres_port = os.environ['POSTGRES_PORT']
    postgres_user = os.environ['POSTGRES_USER']
    postgres_password = os.environ['POSTGRES_PASSWORD']
    postgres_db = os.environ['POSTGRES_DB']
</code></pre>
<h2 id="conecta-ao-banco">Conecta ao banco</h2>
<ul>
<li>Usa as variáveis de ambiente para se conectar ao banco de dados</li>
</ul>
<pre><code class="language-python">connection = psycopg2.connect(
    host=postgres_host,
    port=postgres_port,
    user=postgres_user,
    password=postgres_password,
    dbname=postgres_db
)
    cursor = connection.cursor() 
</code></pre>
<h2 id="criacao-do-server-udp">Criação do Server UDP</h2>
<ul>
<li>A função datagram_received ao receber uma mensagem e caso o prefixo da mensagem nao comece com BINA (protocolo SFB) irá chamar a função parseXVM que faz o parser das mensagens caso esteja no formato XVM</li>
<li>Em seguida chama a função handle_request da classe udp, que precisa da mensagem(data), do ip de origem (addr), o objeto que faz o envio das mensagens (transport) e o device_id</li>
<li>Utilzei o device '0306' para o exemplo, caso as mensagens que chegam sejam dele, irá printar na tela para debug</li>
<li>Caso as mensagens contenham o prefixo BINA a mensagem é printada </li>
</ul>
<pre><code class="language-python">class MyDatagramProtocol(asyncio.DatagramProtocol):
    def connection_made(self, transport):
        self.transport = transport
        self.ids = []

    def datagram_received(self, data, addr):
        if re.search('BINA.*',data.decode(errors='ignore')) is None:
            if XVM.isValidXVM(data.decode(errors='ignore')):
                xvmMessage = XVM.parseXVM(data.decode(errors='ignore'))
                msg = xvmMessage[0]
                device_id = xvmMessage[1]
                asyncio.create_task(udp().handle_request(data, addr, self.transport,device_id))
                if device_id == '0306':
                    print(data)
        if re.search(b'BINA.*',data) is not None:
            print(data)
</code></pre>
<h2 id="classe-udp">Classe udp</h2>
<h3 id="funcao-handle_request">Função Handle_request</h3>
<ul>
<li>A função handle_request da classe udp recebe os parametros já mencionados</li>
<li>Caso a mensagem recebida seja de um device que não esteja na lista LISTENED e também nao esteja na lista de IDs no banco de dados irá enviar o comando &gt;QSN&lt; para capturar o SN do equipamento, utilizando a função generateXVM que deixa no protocolo XVM</li>
<li>Em seguida envia a mensagem utilizando o transport.sendto para o ip do device (addr)</li>
<li>Ao receber a resposta que irá começar com &gt;RSN, salva na vairavel sn, e adiciona o device_id na lista de devices ja escutados (LISTENED) e também no dicionário RSN_DICT</li>
<li>Em seguida chama uma sequencia de outras funções da classe udp (envioScript,Arquivos,fdir)<ul>
<li>envioScript, Envia os comandos do script basico do copiloto</li>
<li>Arquivos, Envia os arquivos de audio</li>
<li>fdir, Confere quantas vozes o equipamento possui embarcado</li>
</ul>
</li>
<li>Ao final da função fdir, caso a mensagem que chegue contenha EOF é capturada dentro dessa mensagem o numero de vozes embarcado no equipamento</li>
<li>No final do processo é chamada a função criar que faz o insert no banco </li>
</ul>
<pre><code class="language-python">class udp():
    async def handle_request(self,data, addr, transport,device_id):
        self.message = data.decode(errors='ignore')
        if device_id == '0306' and not LISTENED and not ID:
            xvm = XVM.generateXVM(device_id,str(8000).zfill(4),'&gt;QSN&lt;')
            print(xvm)
            transport.sendto(xvm.encode(), addr)
            result = re.search('&gt;RSN.*',self.message)
            if result is not None:
                rsn = result.group()
                self.sn = rsn.split('_')[0].split('&gt;RSN')[1]
                if self.sn:
                    LISTENED.append(device_id)
                    RSN_DICT[device_id]=self.sn
                    print(RSN_DICT)
                    await self.envioScript(transport,addr,device_id)
                    await self.Arquivos(transport,self.message,addr,device_id)
                    await self.fdir(transport,addr,device_id)
        if re.search('&gt;.*EOF.*',self.message) is not None:
            fdir = re.search('&gt;.*EOF.*',self.message)
            self.vozes = fdir.group().split('_')[2].split(':')[1]
            print('\nFDIR:',self.vozes)
            await self.criar(device_id)
</code></pre>
<h3 id="funcao-arquivos">Função Arquivos</h3>
<ul>
<li>Essa função lê os arquivos de audio, utilizando o caminho para os mesmos, contido na variavel path_voz e formata no seguindo o protocolo SFB</li>
<li>Para cada bloco de 520 bytes, a função monta os blocos com o cabeçalho + conteudo + SN do equipamento + numero da msg(começando em 80000000) + cs (função para calcular o crc)</li>
<li>Usa a transport.sendto para enviar cada bloco de bytes para o endereço do equipamento e aguarda 0.5s para receber o ACK de resposta</li>
</ul>
<h6 id="envio-de-sfb">Envio de SFB</h6>
<ul>
<li>Pacotes de 520 bytes consecutivos são capturados do arquivo .SFB em que os primeiros 4 bytes são o 
endereço de memória e os últimos 4 bytes são o chksum dos dados.
Sendo então os pacotes a enviar para o dispositivo compostos da seguinte forma:<ul>
<li>Cabeçalho BINAVSFB (8 bytes)</li>
<li>Dados SFB (520 bytes)</li>
<li>Número de série do equipamento (8 bytes)</li>
<li>Nº de mensagem (4 bytes)</li>
<li>Chksum (4 bytes)</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    async def Arquivos(self,transport,message,addr,device_id):
        sn = RSN_DICT[device_id]
        print(path_voz)
        for files in path_voz:
            f=open(f'{files}','rb')
            conteudo = f.read()
            separar = [conteudo[i:i+520]for i in range(0,len(conteudo),520)]
            print('\n',files,'\n')
            msg = '80000000'
            for i in range(len(separar)):
                bloco = cabeçalho.encode().hex()+separar[i].hex()+sn.encode().hex()
                sep = re.findall('........',bloco)
                sep.append(msg)
                cs =  await self.crc(sep)
                bloc = bloco+msg+cs
                msg = int(msg,16)+1
                msg = format(msg,'X')
                b = bytes.fromhex(bloc)
                transport.sendto(b, addr)
                await asyncio.sleep(0.5)
</code></pre>
<h3 id="funcao-crc">Função crc</h3>
<ul>
<li>Função que calcula o checksum de cada bloco de mensagem do protocolo SFB</li>
</ul>
<pre><code class="language-python">    async def crc(self,x): 
        cs_int = 0
        sep = x
        for i in range(len(sep)):
            cs_int ^= (int(sep[i],16)) 
        hexcs = hex(cs_int).replace('0x','')
        return hexcs   
</code></pre>
<h3 id="funcao-criar">Função criar</h3>
<ul>
<li>Função que faz o insert dos dados do equipamento no bando de dados<ul>
<li>coluna IMEI recebe device_id</li>
<li>coluna SN recebe o SN do copiloto</li>
<li>coluna VOZES recebe a quantidade de vozes embarcadas no equipamento</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    async def criar(self,device_id):
        try:
            sn = RSN_DICT[device_id]
            cursor.execute('INSERT INTO vozes (&quot;IMEI&quot;, &quot;SN&quot;, &quot;VOZES&quot;) \
                            values (\'{}\', \'{}\', \'{}\');'.format(device_id, sn,self.vozes))
            connection.commit()
        except:
            pass
</code></pre>
<h3 id="funcao-fdir">Função fdir</h3>
<ul>
<li>Envia o comando &gt;FDIR&lt; para o copiloto, no formato XVM utilizando a função generareXVM</li>
</ul>
<pre><code class="language-python">    async def fdir(self,transport,addr,device_id):
        try:
            xvm = XVM.generateXVM(device_id,str(8010).zfill(4),'&gt;FDIR&lt;')
            print(xvm)
            transport.sendto(xvm.encode(), addr)
            if re.search('&gt;.*EOF.*',self.message) is not None:
                fdir = re.search('&gt;.*EOF.*',self.message)
                self.vozes = fdir.group().split('_')[2].split(':')[1]
                print('\nFDIR:',self.vozes)
                return self.vozes 
        except:
            raise Exception
</code></pre>
<h3 id="funcao-envioscript">Função envioScript</h3>
<ul>
<li>Le o conteudo do arquivo, que o diretório esta salvo na variavel path_script, filtra apenas os comandos, estão entre &gt;&lt;</li>
<li>Faz o envio dos comandos, no formato XVM e utilizando o transport.sendto </li>
</ul>
<pre><code class="language-python">    async def envioScript(self,transport,addr,device_id):
        for i in path_script:
            with open(f'{i}') as f:
                self.tudo = f.read()
            self.comandos=(re.findall('(&gt;.*&lt;)', self.tudo))
            for i in range(len(self.comandos)):
                try:
                    xvm = XVM.generateXVM(device_id,str(8010+i).zfill(4),self.comandos[i])
                    transport.sendto(xvm.encode(),addr)
                    await asyncio.sleep(0.3)
                except:
                    raise Exception
</code></pre>
<h2 id="funcao-main">Função main</h2>
<ul>
<li>Função assincrona que cria um endpoint de datagrama, que recebe dois argumentos a função MyDatagramProtocol e o endereço para vincular o servidor, no caso está no (0.0.0.0 na porta 10117) dentro do container, comentando, outros exemplos de ip e porta para utilizar</li>
</ul>
<pre><code class="language-python">async def main():
    loop = asyncio.get_running_loop()
    transport, protocol = await loop.create_datagram_endpoint(
        lambda: MyDatagramProtocol(),
        local_addr=('0.0.0.0', 10117),
        family=socket.AF_INET)
    print(f&quot;Server started on {transport.get_extra_info('sockname')}&quot;)
    try:
        while True:
            await asyncio.sleep(0.1)
    except asyncio.CancelledError:
        pass
    finally:
        transport.close()
</code></pre>
<h2 id="funcao-find">Função find</h2>
<ul>
<li>Função que procura todos os arquivos dentro de um local, que é passado como argumento (pasta). E os salva dentro da lista path</li>
</ul>
<pre><code class="language-python">def find(pasta):
    arquivos = os.listdir(pasta)
    for arquivo in arquivos:
        caminho_arquivo = os.path.join(pasta, arquivo)
        if os.path.isfile(caminho_arquivo):
            path.append(caminho_arquivo)
    return path
</code></pre>
<h2 id="inicializacao-do-script">Inicialização do Script</h2>
<ul>
<li>Faz um select no banco e coleta todos os device_id que já inseridos (ID), para se os mesmo enviarem mensagem para o servidor, não serem reconfigurados</li>
<li>path_voz chama a função find e passa o caminho para os arquivos de voz, e a função retorna a lista dos arquivos dentro do diretório</li>
<li>path_script chama a função find e passa o caminho para o script basico, e a função retorna a lista do arquivo dentro do diretório</li>
</ul>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    try:
        cursor.execute('SELECT &quot;IMEI&quot; FROM vozes;')
        results = cursor.fetchall()
        ID = [result[0] for result in results]
        pasta_vozes = &quot;./app/Files/Vozes/&quot;
        pasta_scripts = &quot;./app/Files/Prod_script/&quot;
        path_voz = find(pasta_vozes)
        path = []
        path_script = find(pasta_scripts)
        if path_voz:
            asyncio.run(main())
    except KeyboardInterrupt:
        pass
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../docker/" class="btn btn-neutral float-left" title="Docker"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../docker/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
