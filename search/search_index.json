{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Autoconfigura\u00e7\u00e3o dos Copilotos Documenta\u00e7\u00e3o para da aplica\u00e7\u00e3o em python para autoconfigura\u00e7\u00e3o dos copilotos em produ\u00e7\u00e3o Nessa aplica\u00e7\u00e3o \u00e9 utilizado um instancia ubuntu da AWS e nela foi criado 3 containers utilizando docker, um servi\u00e7o com a aplica\u00e7\u00e3o em python, um banco postgres e tamb\u00e9m Grafana Bibliotecas Python import asyncio - Biblioteca para codigo ass\u00edncrono import socket - Biblioteca para criar server UDP import XVM - Biblioteca para formata\u00e7\u00e3o do XVM (linguagem do copiloto) import re - Biblioteca para utilizar express\u00e3o regular import psycopg2 - Biblioteca para se conectar no banco postgres import os - Biblioteca para interagir com o sistema operacional Comandos Docker Rodar aplica\u00e7\u00e3o levantar as aplica\u00e7\u00f5es do docker compose docker compose up --build Apagar aplica\u00e7\u00e3o Apaga as aplica\u00e7\u00f5es e tamb\u00e9m remove a suas imagens geradas no build docker compose down --rmi all Remover todos os containers docker rm $(docker ps -a) Remover todos as imagens docker rmi $(docker images -q) Subir apenas o Banco Postgres docker compose -f docker-compose.yml up -d Subir apenas a aplica\u00e7\u00e3o Python docker compose -f server-prod.yml up --build Configura\u00e7\u00e3o dos Copilotos Enviar arquivo de APN correspondente ao SIM Card inserido no Copliloto Configurar IP do server apontar o copiloto para o IP da maquina na AWS (caso interrompa o a maquina o IP muda, e deve ser reconfigurado no copiloto) VSIP0,54.207.138.190.4096.10116 Configura\u00e7\u00e3o da EC2 da AWS Maquina t2.micro ubuntu Liberar acesso UDP na porta 10116 Liberar acesso TCP 3000(grafana) e 5432(postgres) ou todos TCP Grafana No Grafana apenas precisa configurar o Database do Postgres, inserir o IP da maquina da AWS porta 5432, Database, user e password desta aplica\u00e7\u00e3o \u00e9 \"postgres\" e marcar TLS como disable","title":"Autoconfigura\u00e7\u00e3o dos Copilotos"},{"location":"#autoconfiguracao-dos-copilotos","text":"Documenta\u00e7\u00e3o para da aplica\u00e7\u00e3o em python para autoconfigura\u00e7\u00e3o dos copilotos em produ\u00e7\u00e3o Nessa aplica\u00e7\u00e3o \u00e9 utilizado um instancia ubuntu da AWS e nela foi criado 3 containers utilizando docker, um servi\u00e7o com a aplica\u00e7\u00e3o em python, um banco postgres e tamb\u00e9m Grafana","title":"Autoconfigura\u00e7\u00e3o dos Copilotos"},{"location":"#bibliotecas-python","text":"import asyncio - Biblioteca para codigo ass\u00edncrono import socket - Biblioteca para criar server UDP import XVM - Biblioteca para formata\u00e7\u00e3o do XVM (linguagem do copiloto) import re - Biblioteca para utilizar express\u00e3o regular import psycopg2 - Biblioteca para se conectar no banco postgres import os - Biblioteca para interagir com o sistema operacional","title":"Bibliotecas Python"},{"location":"#comandos-docker","text":"","title":"Comandos Docker"},{"location":"#rodar-aplicacao","text":"levantar as aplica\u00e7\u00f5es do docker compose docker compose up --build","title":"Rodar aplica\u00e7\u00e3o"},{"location":"#apagar-aplicacao","text":"Apaga as aplica\u00e7\u00f5es e tamb\u00e9m remove a suas imagens geradas no build docker compose down --rmi all","title":"Apagar aplica\u00e7\u00e3o"},{"location":"#remover-todos-os-containers","text":"docker rm $(docker ps -a)","title":"Remover todos os containers"},{"location":"#remover-todos-as-imagens","text":"docker rmi $(docker images -q)","title":"Remover todos as imagens"},{"location":"#subir-apenas-o-banco-postgres","text":"docker compose -f docker-compose.yml up -d","title":"Subir apenas o Banco Postgres"},{"location":"#subir-apenas-a-aplicacao-python","text":"docker compose -f server-prod.yml up --build","title":"Subir apenas a aplica\u00e7\u00e3o Python"},{"location":"#configuracao-dos-copilotos","text":"Enviar arquivo de APN correspondente ao SIM Card inserido no Copliloto","title":"Configura\u00e7\u00e3o dos Copilotos"},{"location":"#configurar-ip-do-server","text":"apontar o copiloto para o IP da maquina na AWS (caso interrompa o a maquina o IP muda, e deve ser reconfigurado no copiloto) VSIP0,54.207.138.190.4096.10116","title":"Configurar IP do server"},{"location":"#configuracao-da-ec2-da-aws","text":"Maquina t2.micro ubuntu Liberar acesso UDP na porta 10116 Liberar acesso TCP 3000(grafana) e 5432(postgres) ou todos TCP","title":"Configura\u00e7\u00e3o da EC2 da AWS"},{"location":"#grafana","text":"No Grafana apenas precisa configurar o Database do Postgres, inserir o IP da maquina da AWS porta 5432, Database, user e password desta aplica\u00e7\u00e3o \u00e9 \"postgres\" e marcar TLS como disable","title":"Grafana"},{"location":"XVM/","text":"XVM calcCheckSum Fun\u00e7\u00e3o respons\u00e1vel para calcular o checksum de cada mensagem no padr\u00e3o XVM Recebe: mensagem(str) def calcCheckSum (msg): num = msg.find(';*')+1 calc = 0 for i in range(num): calc ^= ord(msg[i]) return calc parseXVM Fun\u00e7\u00e3o respons\u00e1vel por separar todos os atributos contidos em uma mensagem XVM Recebe: mensagem(str) def parseXVM(msg): xvmMessage=msg.split(';') message = xvmMessage[0] id = xvmMessage[1][3:] sequence = int(xvmMessage[2][1:],16) checksum = int(xvmMessage[3][1:3],16) return (message,id,sequence,checksum) generateAck Fun\u00e7\u00e3o que gera o ACK do copiloto Recebe: id (str) e sequence (str) def generateAck(id,sequence): resp = '>ACK;ID='+id+';#'+format(sequence,'04X')+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp generateXVM Fun\u00e7\u00e3o que gera uma mensagem XVM Recebe: id (str), sequence (str), message (str) def generateXVM(id,sequence,message): resp = message+';ID='+id+';#'+sequence+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp isValidXVM Fun\u00e7\u00e3o valida se a mensagem recebida \u00e9 uma mensagem no padr\u00e3o XVM Recebe: id (str), sequence (str), message (str) def isValidXVM(msg): return 1 if calcCheckSum(msg)==parseXVM(msg)[3] else 0","title":"XVM"},{"location":"XVM/#xvm","text":"","title":"XVM"},{"location":"XVM/#calcchecksum","text":"Fun\u00e7\u00e3o respons\u00e1vel para calcular o checksum de cada mensagem no padr\u00e3o XVM Recebe: mensagem(str) def calcCheckSum (msg): num = msg.find(';*')+1 calc = 0 for i in range(num): calc ^= ord(msg[i]) return calc","title":"calcCheckSum"},{"location":"XVM/#parsexvm","text":"Fun\u00e7\u00e3o respons\u00e1vel por separar todos os atributos contidos em uma mensagem XVM Recebe: mensagem(str) def parseXVM(msg): xvmMessage=msg.split(';') message = xvmMessage[0] id = xvmMessage[1][3:] sequence = int(xvmMessage[2][1:],16) checksum = int(xvmMessage[3][1:3],16) return (message,id,sequence,checksum)","title":"parseXVM"},{"location":"XVM/#generateack","text":"Fun\u00e7\u00e3o que gera o ACK do copiloto Recebe: id (str) e sequence (str) def generateAck(id,sequence): resp = '>ACK;ID='+id+';#'+format(sequence,'04X')+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp","title":"generateAck"},{"location":"XVM/#generatexvm","text":"Fun\u00e7\u00e3o que gera uma mensagem XVM Recebe: id (str), sequence (str), message (str) def generateXVM(id,sequence,message): resp = message+';ID='+id+';#'+sequence+';*' resp = resp+format(calcCheckSum(resp),'02X')+'<\\r\\n' return resp","title":"generateXVM"},{"location":"XVM/#isvalidxvm","text":"Fun\u00e7\u00e3o valida se a mensagem recebida \u00e9 uma mensagem no padr\u00e3o XVM Recebe: id (str), sequence (str), message (str) def isValidXVM(msg): return 1 if calcCheckSum(msg)==parseXVM(msg)[3] else 0","title":"isValidXVM"},{"location":"banco/","text":"Banco de Dados init.db tabela para a inser\u00e7\u00e3o dos dados, com exemplo de inser\u00e7\u00e3o Colunas: IMEI: o id do copiloto SN: a mensagem coletada pela serial VOZES: quantidade de vozes embarcada no copiloto reception_datetime: data e hora da coleta da mensagem, timezone de S\u00e3o Paulo CREATE TABLE IF NOT EXISTS public.vozes ( \"IMEI\" text COLLATE pg_catalog.\"default\" NOT NULL, \"SN\" text COLLATE pg_catalog.\"default\" NOT NULL, \"VOZES\" bigint, reception_datetime timestamp with time zone DEFAULT timezone('America/Sao_Paulo', now()) ); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste','teste',22); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste2','teste2',25); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste3','teste3',12); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste4','teste4',3); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste5','teste5',19);","title":"Banco de Dados"},{"location":"banco/#banco-de-dados","text":"","title":"Banco de Dados"},{"location":"banco/#initdb","text":"tabela para a inser\u00e7\u00e3o dos dados, com exemplo de inser\u00e7\u00e3o Colunas: IMEI: o id do copiloto SN: a mensagem coletada pela serial VOZES: quantidade de vozes embarcada no copiloto reception_datetime: data e hora da coleta da mensagem, timezone de S\u00e3o Paulo CREATE TABLE IF NOT EXISTS public.vozes ( \"IMEI\" text COLLATE pg_catalog.\"default\" NOT NULL, \"SN\" text COLLATE pg_catalog.\"default\" NOT NULL, \"VOZES\" bigint, reception_datetime timestamp with time zone DEFAULT timezone('America/Sao_Paulo', now()) ); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste','teste',22); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste2','teste2',25); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste3','teste3',12); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste4','teste4',3); INSERT INTO public.vozes (\"IMEI\",\"SN\",\"VOZES\") VALUES ('teste5','teste5',19);","title":"init.db"},{"location":"docker/","text":"Docker Dockerfile Define a imagem base, imagem do python FROM python:3.9-slim-buster Instala depend\u00eancias neces\u00e1rias RUN apt-get update && apt-get install -y libpq-dev python3-tk net-tools lsof && rm -rf /var/lib/apt/lists/* Define a vari\u00e1vel de ambiente para o diret\u00f3rio de trabalho ENV APP_HOME /app WORKDIR $APP_HOME Copia o requirements.txt e instala as depend\u00eancias COPY ./app/requirements.txt . COPY ./app/udp-server.py . COPY ./app/XVM.py . RUN pip install --no-cache-dir -r requirements.txt Copia o c\u00f3digo fonte COPY . . Define as vari\u00e1veis de ambiente para o banco de dados ENV POSTGRES_HOST=postgres ENV POSTGRES_PORT=5432 ENV POSTGRES_USER=postgres ENV POSTGRES_PASSWORD=postgres ENV POSTGRES_DB=postgres Executa a aplica\u00e7\u00e3o CMD [\"python\", \"-u\",\"./app/udp-server.py\"] YAML para o Docker compose server-prod App build: .: Configura a imagem do servi\u00e7o a partir do Dockerfile localizado no diret\u00f3rio atual. restart: unless-stopped: Essa op\u00e7\u00e3o instrui o Docker a reiniciar o servi\u00e7o automaticamente caso ele seja encerrado, a menos que seja explicitamente parado pelo usu\u00e1rio. ports: - \"10116:10116/udp\": Configura o mapeamento de porta do servi\u00e7o. Neste exemplo, a porta 10116 do container \u00e9 mapeada para a porta 10116 do host, usando o protocolo UDP. depends_on: - postgres: Configura a depend\u00eancia do servi\u00e7o em rela\u00e7\u00e3o a outro servi\u00e7o chamado postgres. Isso significa que o servi\u00e7o atual s\u00f3 ser\u00e1 iniciado ap\u00f3s a inicializa\u00e7\u00e3o do servi\u00e7o postgres. environment: - ENDPOINT=postgres: Configura uma vari\u00e1vel de ambiente chamada ENDPOINT para o valor postgres. external_links: - postgres: Configura o link para o servi\u00e7o postgres, permitindo que o servi\u00e7o atual se conecte ao servi\u00e7o postgres. networks: - backing-services: Configura a rede a ser usada pelo servi\u00e7o. Neste exemplo, o servi\u00e7o est\u00e1 configurado para usar a rede chamada backing-services. version: \"2.1\" services: app: build: . restart: unless-stopped ports: - \"10116:10116/udp\" environment: - ENDPOINT=postgres external_links: - docker_python-postgres-1 networks: - backing-services networks: backing-services: driver: bridge docker-compose Postgres image: postgres:14-alpine3.15: Configura a imagem do servi\u00e7o a ser usada a partir do Docker Hub. Neste exemplo, \u00e9 usada a imagem postgres:14-alpine3.15, que \u00e9 uma vers\u00e3o leve do Postgres baseada no Alpine Linux. ports: [\"5432:5432\"]: Configura o mapeamento de porta do servi\u00e7o. Neste exemplo, a porta 5432 do container \u00e9 mapeada para a porta 5432 do host. restart: always: Configura o comportamento do Docker em rela\u00e7\u00e3o \u00e0 reinicializa\u00e7\u00e3o do servi\u00e7o. Essa op\u00e7\u00e3o instrui o Docker a reiniciar o servi\u00e7o automaticamente caso ele seja encerrado por algum motivo. networks: [backing-services]: Configura a rede a ser usada pelo servi\u00e7o. Neste exemplo, o servi\u00e7o est\u00e1 configurado para usar a rede chamada backing-services. volumes: - Configura os volumes a serem montados no container do servi\u00e7o. Neste exemplo, o primeiro volume mapeia o diret\u00f3rio ./app do host para o diret\u00f3rio /data do container. O segundo volume mapeia o arquivo /mnt/c/Python_scripts/Docker-app/docker-app/Docker_python/db/init.sql do host para o diret\u00f3rio /docker-entrypoint-initdb.d/init.sql do container. Isso permite que o arquivo SQL seja executado na inicializa\u00e7\u00e3o do banco de dados. environment: POSTGRES_DB: postgres POSTGRES_USER: postgres POSTGRES_PASSWORD: postgres: Configura as vari\u00e1veis de ambiente usadas pelo servi\u00e7o Postgres. indicando o nome do banco de dados, usu\u00e1rio e senha a serem usados. postgres: image: postgres:14-alpine3.15 ports: [\"5432:5432\"] restart: always networks: [backing-services] volumes: - ./app:/data - /mnt/c/Python_scripts/Docker-app/docker-app/Docker_python/db/init.sql:/docker-entrypoint-initdb.d/init.sql environment: POSTGRES_DB: postgres POSTGRES_USER: postgres POSTGRES_PASSWORD: postgres # hostname: \"ec2-3-85-175-98.compute-1.amazonaws.com\" Grafana Image: Nome da imagem do Grafana Enterprise usada. Container_name: Nome do cont\u00eainer em execu\u00e7\u00e3o. Restart: Pol\u00edtica de reinicializa\u00e7\u00e3o do cont\u00eainer. Ports: Portas do host mapeadas para as portas do cont\u00eainer. Volumes: Dados persistem entre reinicializa\u00e7\u00f5es do cont\u00eainer. grafana: image: grafana/grafana-enterprise container_name: grafana restart: unless-stopped ports: - '3000:3000' volumes: - grafana_data:/var/lib/grafana Socat N\u00e3o utilizado na vers\u00e3o mais recente!!! image: alpine/socat: Configura a imagem do servi\u00e7o a ser usada a partir do Docker Hub. Neste exemplo, \u00e9 usada a imagem alpine/socat, que \u00e9 uma imagem Alpine do Socat. command: socat TCP4-LISTEN:10116,fork,reuseaddr TCP4:127.0.0.1:10117: Configura o comando a ser executado quando o cont\u00eainer for iniciado. Neste exemplo, o comando socat \u00e9 usado para direcionar o tr\u00e1fego de entrada na porta 10116 para a porta 10117 no endere\u00e7o IP 127.0.0.1. As op\u00e7\u00f5es fork e reuseaddr s\u00e3o usadas para permitir que v\u00e1rias conex\u00f5es sejam gerenciadas e para reutilizar o endere\u00e7o IP e a porta. socat: image: alpine/socat command: socat TCP4-LISTEN:10116,fork,reuseaddr TCP4:127.0.0.1:10117 # command: socat TCP4-LISTEN:65117,fork,reuseaddr TCP4:127.0.0.1:10117","title":"Docker"},{"location":"docker/#docker","text":"","title":"Docker"},{"location":"docker/#dockerfile","text":"","title":"Dockerfile"},{"location":"docker/#define-a-imagem-base-imagem-do-python","text":"FROM python:3.9-slim-buster","title":"Define a imagem base, imagem do python"},{"location":"docker/#instala-dependencias-necesarias","text":"RUN apt-get update && apt-get install -y libpq-dev python3-tk net-tools lsof && rm -rf /var/lib/apt/lists/*","title":"Instala depend\u00eancias neces\u00e1rias"},{"location":"docker/#define-a-variavel-de-ambiente-para-o-diretorio-de-trabalho","text":"ENV APP_HOME /app WORKDIR $APP_HOME","title":"Define a vari\u00e1vel de ambiente para o diret\u00f3rio de trabalho"},{"location":"docker/#copia-o-requirementstxt-e-instala-as-dependencias","text":"COPY ./app/requirements.txt . COPY ./app/udp-server.py . COPY ./app/XVM.py . RUN pip install --no-cache-dir -r requirements.txt","title":"Copia o requirements.txt e instala as depend\u00eancias"},{"location":"docker/#copia-o-codigo-fonte","text":"COPY . .","title":"Copia o c\u00f3digo fonte"},{"location":"docker/#define-as-variaveis-de-ambiente-para-o-banco-de-dados","text":"ENV POSTGRES_HOST=postgres ENV POSTGRES_PORT=5432 ENV POSTGRES_USER=postgres ENV POSTGRES_PASSWORD=postgres ENV POSTGRES_DB=postgres","title":"Define as vari\u00e1veis de ambiente para o banco de dados"},{"location":"docker/#executa-a-aplicacao","text":"CMD [\"python\", \"-u\",\"./app/udp-server.py\"]","title":"Executa a aplica\u00e7\u00e3o"},{"location":"docker/#yaml-para-o-docker-compose","text":"","title":"YAML para o Docker compose"},{"location":"docker/#server-prod","text":"","title":"server-prod"},{"location":"docker/#app","text":"build: .: Configura a imagem do servi\u00e7o a partir do Dockerfile localizado no diret\u00f3rio atual. restart: unless-stopped: Essa op\u00e7\u00e3o instrui o Docker a reiniciar o servi\u00e7o automaticamente caso ele seja encerrado, a menos que seja explicitamente parado pelo usu\u00e1rio. ports: - \"10116:10116/udp\": Configura o mapeamento de porta do servi\u00e7o. Neste exemplo, a porta 10116 do container \u00e9 mapeada para a porta 10116 do host, usando o protocolo UDP. depends_on: - postgres: Configura a depend\u00eancia do servi\u00e7o em rela\u00e7\u00e3o a outro servi\u00e7o chamado postgres. Isso significa que o servi\u00e7o atual s\u00f3 ser\u00e1 iniciado ap\u00f3s a inicializa\u00e7\u00e3o do servi\u00e7o postgres. environment: - ENDPOINT=postgres: Configura uma vari\u00e1vel de ambiente chamada ENDPOINT para o valor postgres. external_links: - postgres: Configura o link para o servi\u00e7o postgres, permitindo que o servi\u00e7o atual se conecte ao servi\u00e7o postgres. networks: - backing-services: Configura a rede a ser usada pelo servi\u00e7o. Neste exemplo, o servi\u00e7o est\u00e1 configurado para usar a rede chamada backing-services. version: \"2.1\" services: app: build: . restart: unless-stopped ports: - \"10116:10116/udp\" environment: - ENDPOINT=postgres external_links: - docker_python-postgres-1 networks: - backing-services networks: backing-services: driver: bridge","title":"App"},{"location":"docker/#docker-compose","text":"","title":"docker-compose"},{"location":"docker/#postgres","text":"image: postgres:14-alpine3.15: Configura a imagem do servi\u00e7o a ser usada a partir do Docker Hub. Neste exemplo, \u00e9 usada a imagem postgres:14-alpine3.15, que \u00e9 uma vers\u00e3o leve do Postgres baseada no Alpine Linux. ports: [\"5432:5432\"]: Configura o mapeamento de porta do servi\u00e7o. Neste exemplo, a porta 5432 do container \u00e9 mapeada para a porta 5432 do host. restart: always: Configura o comportamento do Docker em rela\u00e7\u00e3o \u00e0 reinicializa\u00e7\u00e3o do servi\u00e7o. Essa op\u00e7\u00e3o instrui o Docker a reiniciar o servi\u00e7o automaticamente caso ele seja encerrado por algum motivo. networks: [backing-services]: Configura a rede a ser usada pelo servi\u00e7o. Neste exemplo, o servi\u00e7o est\u00e1 configurado para usar a rede chamada backing-services. volumes: - Configura os volumes a serem montados no container do servi\u00e7o. Neste exemplo, o primeiro volume mapeia o diret\u00f3rio ./app do host para o diret\u00f3rio /data do container. O segundo volume mapeia o arquivo /mnt/c/Python_scripts/Docker-app/docker-app/Docker_python/db/init.sql do host para o diret\u00f3rio /docker-entrypoint-initdb.d/init.sql do container. Isso permite que o arquivo SQL seja executado na inicializa\u00e7\u00e3o do banco de dados. environment: POSTGRES_DB: postgres POSTGRES_USER: postgres POSTGRES_PASSWORD: postgres: Configura as vari\u00e1veis de ambiente usadas pelo servi\u00e7o Postgres. indicando o nome do banco de dados, usu\u00e1rio e senha a serem usados. postgres: image: postgres:14-alpine3.15 ports: [\"5432:5432\"] restart: always networks: [backing-services] volumes: - ./app:/data - /mnt/c/Python_scripts/Docker-app/docker-app/Docker_python/db/init.sql:/docker-entrypoint-initdb.d/init.sql environment: POSTGRES_DB: postgres POSTGRES_USER: postgres POSTGRES_PASSWORD: postgres # hostname: \"ec2-3-85-175-98.compute-1.amazonaws.com\"","title":"Postgres"},{"location":"docker/#grafana","text":"Image: Nome da imagem do Grafana Enterprise usada. Container_name: Nome do cont\u00eainer em execu\u00e7\u00e3o. Restart: Pol\u00edtica de reinicializa\u00e7\u00e3o do cont\u00eainer. Ports: Portas do host mapeadas para as portas do cont\u00eainer. Volumes: Dados persistem entre reinicializa\u00e7\u00f5es do cont\u00eainer. grafana: image: grafana/grafana-enterprise container_name: grafana restart: unless-stopped ports: - '3000:3000' volumes: - grafana_data:/var/lib/grafana","title":"Grafana"},{"location":"docker/#socat","text":"","title":"Socat"},{"location":"docker/#nao-utilizado-na-versao-mais-recente","text":"image: alpine/socat: Configura a imagem do servi\u00e7o a ser usada a partir do Docker Hub. Neste exemplo, \u00e9 usada a imagem alpine/socat, que \u00e9 uma imagem Alpine do Socat. command: socat TCP4-LISTEN:10116,fork,reuseaddr TCP4:127.0.0.1:10117: Configura o comando a ser executado quando o cont\u00eainer for iniciado. Neste exemplo, o comando socat \u00e9 usado para direcionar o tr\u00e1fego de entrada na porta 10116 para a porta 10117 no endere\u00e7o IP 127.0.0.1. As op\u00e7\u00f5es fork e reuseaddr s\u00e3o usadas para permitir que v\u00e1rias conex\u00f5es sejam gerenciadas e para reutilizar o endere\u00e7o IP e a porta. socat: image: alpine/socat command: socat TCP4-LISTEN:10116,fork,reuseaddr TCP4:127.0.0.1:10117 # command: socat TCP4-LISTEN:65117,fork,reuseaddr TCP4:127.0.0.1:10117","title":"N\u00e3o utilizado na vers\u00e3o mais recente!!!"},{"location":"udp-server/","text":"UDP server Arquivo udp-server.py L\u00ea as vari\u00e1veis de ambiente do dockerfile postgres_host = os.environ['POSTGRES_HOST'] postgres_port = os.environ['POSTGRES_PORT'] postgres_user = os.environ['POSTGRES_USER'] postgres_password = os.environ['POSTGRES_PASSWORD'] postgres_db = os.environ['POSTGRES_DB'] Conecta ao banco Usa as vari\u00e1veis de ambiente para se conectar ao banco de dados connection = psycopg2.connect( host=postgres_host, port=postgres_port, user=postgres_user, password=postgres_password, dbname=postgres_db ) cursor = connection.cursor() Cria\u00e7\u00e3o do Server UDP A fun\u00e7\u00e3o datagram_received ao receber uma mensagem e caso o prefixo da mensagem nao comece com BINA (protocolo SFB) ir\u00e1 chamar a fun\u00e7\u00e3o parseXVM que faz o parser das mensagens caso esteja no formato XVM Em seguida chama a fun\u00e7\u00e3o handle_request da classe udp, que precisa da mensagem(data), do ip de origem (addr), o objeto que faz o envio das mensagens (transport) e o device_id Utilzei o device '0306' para o exemplo, caso as mensagens que chegam sejam dele, ir\u00e1 printar na tela para debug Caso as mensagens contenham o prefixo BINA a mensagem \u00e9 printada class MyDatagramProtocol(asyncio.DatagramProtocol): def connection_made(self, transport): self.transport = transport self.ids = [] def datagram_received(self, data, addr): if re.search('BINA.*',data.decode(errors='ignore')) is None: if XVM.isValidXVM(data.decode(errors='ignore')): xvmMessage = XVM.parseXVM(data.decode(errors='ignore')) msg = xvmMessage[0] device_id = xvmMessage[1] asyncio.create_task(udp().handle_request(data, addr, self.transport,device_id)) if device_id == '0306': print(data) if re.search(b'BINA.*',data) is not None: print(data) Classe udp Fun\u00e7\u00e3o Handle_request A fun\u00e7\u00e3o handle_request da classe udp recebe os parametros j\u00e1 mencionados Caso a mensagem recebida seja de um device que n\u00e3o esteja na lista LISTENED e tamb\u00e9m nao esteja na lista de IDs no banco de dados ir\u00e1 enviar o comando >QSN< para capturar o SN do equipamento, utilizando a fun\u00e7\u00e3o generateXVM que deixa no protocolo XVM Em seguida envia a mensagem utilizando o transport.sendto para o ip do device (addr) Ao receber a resposta que ir\u00e1 come\u00e7ar com >RSN, salva na vairavel sn, e adiciona o device_id na lista de devices ja escutados (LISTENED) e tamb\u00e9m no dicion\u00e1rio RSN_DICT Em seguida chama uma sequencia de outras fun\u00e7\u00f5es da classe udp (envioScript,Arquivos,fdir) envioScript, Envia os comandos do script basico do copiloto Arquivos, Envia os arquivos de audio fdir, Confere quantas vozes o equipamento possui embarcado Ao final da fun\u00e7\u00e3o fdir, caso a mensagem que chegue contenha EOF \u00e9 capturada dentro dessa mensagem o numero de vozes embarcado no equipamento No final do processo \u00e9 chamada a fun\u00e7\u00e3o criar que faz o insert no banco class udp(): async def handle_request(self,data, addr, transport,device_id): self.message = data.decode(errors='ignore') if device_id == '0306' and not LISTENED and not ID: xvm = XVM.generateXVM(device_id,str(8000).zfill(4),'>QSN<') print(xvm) transport.sendto(xvm.encode(), addr) result = re.search('>RSN.*',self.message) if result is not None: rsn = result.group() self.sn = rsn.split('_')[0].split('>RSN')[1] if self.sn: LISTENED.append(device_id) RSN_DICT[device_id]=self.sn print(RSN_DICT) await self.envioScript(transport,addr,device_id) await self.Arquivos(transport,self.message,addr,device_id) await self.fdir(transport,addr,device_id) if re.search('>.*EOF.*',self.message) is not None: fdir = re.search('>.*EOF.*',self.message) self.vozes = fdir.group().split('_')[2].split(':')[1] print('\\nFDIR:',self.vozes) await self.criar(device_id) Fun\u00e7\u00e3o Arquivos Essa fun\u00e7\u00e3o l\u00ea os arquivos de audio, utilizando o caminho para os mesmos, contido na variavel path_voz e formata no seguindo o protocolo SFB Para cada bloco de 520 bytes, a fun\u00e7\u00e3o monta os blocos com o cabe\u00e7alho + conteudo + SN do equipamento + numero da msg(come\u00e7ando em 80000000) + cs (fun\u00e7\u00e3o para calcular o crc) Usa a transport.sendto para enviar cada bloco de bytes para o endere\u00e7o do equipamento e aguarda 0.5s para receber o ACK de resposta Envio de SFB Pacotes de 520 bytes consecutivos s\u00e3o capturados do arquivo .SFB em que os primeiros 4 bytes s\u00e3o o endere\u00e7o de mem\u00f3ria e os \u00faltimos 4 bytes s\u00e3o o chksum dos dados. Sendo ent\u00e3o os pacotes a enviar para o dispositivo compostos da seguinte forma: Cabe\u00e7alho BINAVSFB (8 bytes) Dados SFB (520 bytes) N\u00famero de s\u00e9rie do equipamento (8 bytes) N\u00ba de mensagem (4 bytes) Chksum (4 bytes) async def Arquivos(self,transport,message,addr,device_id): sn = RSN_DICT[device_id] print(path_voz) for files in path_voz: f=open(f'{files}','rb') conteudo = f.read() separar = [conteudo[i:i+520]for i in range(0,len(conteudo),520)] print('\\n',files,'\\n') msg = '80000000' for i in range(len(separar)): bloco = cabe\u00e7alho.encode().hex()+separar[i].hex()+sn.encode().hex() sep = re.findall('........',bloco) sep.append(msg) cs = await self.crc(sep) bloc = bloco+msg+cs msg = int(msg,16)+1 msg = format(msg,'X') b = bytes.fromhex(bloc) transport.sendto(b, addr) await asyncio.sleep(0.5) Fun\u00e7\u00e3o crc Fun\u00e7\u00e3o que calcula o checksum de cada bloco de mensagem do protocolo SFB async def crc(self,x): cs_int = 0 sep = x for i in range(len(sep)): cs_int ^= (int(sep[i],16)) hexcs = hex(cs_int).replace('0x','') return hexcs Fun\u00e7\u00e3o criar Fun\u00e7\u00e3o que faz o insert dos dados do equipamento no bando de dados coluna IMEI recebe device_id coluna SN recebe o SN do copiloto coluna VOZES recebe a quantidade de vozes embarcadas no equipamento async def criar(self,device_id): try: sn = RSN_DICT[device_id] cursor.execute('INSERT INTO vozes (\"IMEI\", \"SN\", \"VOZES\") \\ values (\\'{}\\', \\'{}\\', \\'{}\\');'.format(device_id, sn,self.vozes)) connection.commit() except: pass Fun\u00e7\u00e3o fdir Envia o comando >FDIR< para o copiloto, no formato XVM utilizando a fun\u00e7\u00e3o generareXVM async def fdir(self,transport,addr,device_id): try: xvm = XVM.generateXVM(device_id,str(8010).zfill(4),'>FDIR<') print(xvm) transport.sendto(xvm.encode(), addr) if re.search('>.*EOF.*',self.message) is not None: fdir = re.search('>.*EOF.*',self.message) self.vozes = fdir.group().split('_')[2].split(':')[1] print('\\nFDIR:',self.vozes) return self.vozes except: raise Exception Fun\u00e7\u00e3o envioScript Le o conteudo do arquivo, que o diret\u00f3rio esta salvo na variavel path_script, filtra apenas os comandos, est\u00e3o entre >< Faz o envio dos comandos, no formato XVM e utilizando o transport.sendto async def envioScript(self,transport,addr,device_id): for i in path_script: with open(f'{i}') as f: self.tudo = f.read() self.comandos=(re.findall('(>.*<)', self.tudo)) for i in range(len(self.comandos)): try: xvm = XVM.generateXVM(device_id,str(8010+i).zfill(4),self.comandos[i]) transport.sendto(xvm.encode(),addr) await asyncio.sleep(0.3) except: raise Exception Fun\u00e7\u00e3o main Fun\u00e7\u00e3o assincrona que cria um endpoint de datagrama, que recebe dois argumentos a fun\u00e7\u00e3o MyDatagramProtocol e o endere\u00e7o para vincular o servidor, no caso est\u00e1 no (0.0.0.0 na porta 10117) dentro do container, comentando, outros exemplos de ip e porta para utilizar async def main(): loop = asyncio.get_running_loop() transport, protocol = await loop.create_datagram_endpoint( lambda: MyDatagramProtocol(), local_addr=('0.0.0.0', 10117), family=socket.AF_INET) print(f\"Server started on {transport.get_extra_info('sockname')}\") try: while True: await asyncio.sleep(0.1) except asyncio.CancelledError: pass finally: transport.close() Fun\u00e7\u00e3o find Fun\u00e7\u00e3o que procura todos os arquivos dentro de um local, que \u00e9 passado como argumento (pasta). E os salva dentro da lista path def find(pasta): arquivos = os.listdir(pasta) for arquivo in arquivos: caminho_arquivo = os.path.join(pasta, arquivo) if os.path.isfile(caminho_arquivo): path.append(caminho_arquivo) return path Inicializa\u00e7\u00e3o do Script Faz um select no banco e coleta todos os device_id que j\u00e1 inseridos (ID), para se os mesmo enviarem mensagem para o servidor, n\u00e3o serem reconfigurados path_voz chama a fun\u00e7\u00e3o find e passa o caminho para os arquivos de voz, e a fun\u00e7\u00e3o retorna a lista dos arquivos dentro do diret\u00f3rio path_script chama a fun\u00e7\u00e3o find e passa o caminho para o script basico, e a fun\u00e7\u00e3o retorna a lista do arquivo dentro do diret\u00f3rio if __name__ == \"__main__\": try: cursor.execute('SELECT \"IMEI\" FROM vozes;') results = cursor.fetchall() ID = [result[0] for result in results] pasta_vozes = \"./app/Files/Vozes/\" pasta_scripts = \"./app/Files/Prod_script/\" path_voz = find(pasta_vozes) path = [] path_script = find(pasta_scripts) if path_voz: asyncio.run(main()) except KeyboardInterrupt: pass","title":"UDP server"},{"location":"udp-server/#udp-server","text":"Arquivo udp-server.py","title":"UDP server"},{"location":"udp-server/#le-as-variaveis-de-ambiente-do-dockerfile","text":"postgres_host = os.environ['POSTGRES_HOST'] postgres_port = os.environ['POSTGRES_PORT'] postgres_user = os.environ['POSTGRES_USER'] postgres_password = os.environ['POSTGRES_PASSWORD'] postgres_db = os.environ['POSTGRES_DB']","title":"L\u00ea as vari\u00e1veis de ambiente do dockerfile"},{"location":"udp-server/#conecta-ao-banco","text":"Usa as vari\u00e1veis de ambiente para se conectar ao banco de dados connection = psycopg2.connect( host=postgres_host, port=postgres_port, user=postgres_user, password=postgres_password, dbname=postgres_db ) cursor = connection.cursor()","title":"Conecta ao banco"},{"location":"udp-server/#criacao-do-server-udp","text":"A fun\u00e7\u00e3o datagram_received ao receber uma mensagem e caso o prefixo da mensagem nao comece com BINA (protocolo SFB) ir\u00e1 chamar a fun\u00e7\u00e3o parseXVM que faz o parser das mensagens caso esteja no formato XVM Em seguida chama a fun\u00e7\u00e3o handle_request da classe udp, que precisa da mensagem(data), do ip de origem (addr), o objeto que faz o envio das mensagens (transport) e o device_id Utilzei o device '0306' para o exemplo, caso as mensagens que chegam sejam dele, ir\u00e1 printar na tela para debug Caso as mensagens contenham o prefixo BINA a mensagem \u00e9 printada class MyDatagramProtocol(asyncio.DatagramProtocol): def connection_made(self, transport): self.transport = transport self.ids = [] def datagram_received(self, data, addr): if re.search('BINA.*',data.decode(errors='ignore')) is None: if XVM.isValidXVM(data.decode(errors='ignore')): xvmMessage = XVM.parseXVM(data.decode(errors='ignore')) msg = xvmMessage[0] device_id = xvmMessage[1] asyncio.create_task(udp().handle_request(data, addr, self.transport,device_id)) if device_id == '0306': print(data) if re.search(b'BINA.*',data) is not None: print(data)","title":"Cria\u00e7\u00e3o do Server UDP"},{"location":"udp-server/#classe-udp","text":"","title":"Classe udp"},{"location":"udp-server/#funcao-handle_request","text":"A fun\u00e7\u00e3o handle_request da classe udp recebe os parametros j\u00e1 mencionados Caso a mensagem recebida seja de um device que n\u00e3o esteja na lista LISTENED e tamb\u00e9m nao esteja na lista de IDs no banco de dados ir\u00e1 enviar o comando >QSN< para capturar o SN do equipamento, utilizando a fun\u00e7\u00e3o generateXVM que deixa no protocolo XVM Em seguida envia a mensagem utilizando o transport.sendto para o ip do device (addr) Ao receber a resposta que ir\u00e1 come\u00e7ar com >RSN, salva na vairavel sn, e adiciona o device_id na lista de devices ja escutados (LISTENED) e tamb\u00e9m no dicion\u00e1rio RSN_DICT Em seguida chama uma sequencia de outras fun\u00e7\u00f5es da classe udp (envioScript,Arquivos,fdir) envioScript, Envia os comandos do script basico do copiloto Arquivos, Envia os arquivos de audio fdir, Confere quantas vozes o equipamento possui embarcado Ao final da fun\u00e7\u00e3o fdir, caso a mensagem que chegue contenha EOF \u00e9 capturada dentro dessa mensagem o numero de vozes embarcado no equipamento No final do processo \u00e9 chamada a fun\u00e7\u00e3o criar que faz o insert no banco class udp(): async def handle_request(self,data, addr, transport,device_id): self.message = data.decode(errors='ignore') if device_id == '0306' and not LISTENED and not ID: xvm = XVM.generateXVM(device_id,str(8000).zfill(4),'>QSN<') print(xvm) transport.sendto(xvm.encode(), addr) result = re.search('>RSN.*',self.message) if result is not None: rsn = result.group() self.sn = rsn.split('_')[0].split('>RSN')[1] if self.sn: LISTENED.append(device_id) RSN_DICT[device_id]=self.sn print(RSN_DICT) await self.envioScript(transport,addr,device_id) await self.Arquivos(transport,self.message,addr,device_id) await self.fdir(transport,addr,device_id) if re.search('>.*EOF.*',self.message) is not None: fdir = re.search('>.*EOF.*',self.message) self.vozes = fdir.group().split('_')[2].split(':')[1] print('\\nFDIR:',self.vozes) await self.criar(device_id)","title":"Fun\u00e7\u00e3o Handle_request"},{"location":"udp-server/#funcao-arquivos","text":"Essa fun\u00e7\u00e3o l\u00ea os arquivos de audio, utilizando o caminho para os mesmos, contido na variavel path_voz e formata no seguindo o protocolo SFB Para cada bloco de 520 bytes, a fun\u00e7\u00e3o monta os blocos com o cabe\u00e7alho + conteudo + SN do equipamento + numero da msg(come\u00e7ando em 80000000) + cs (fun\u00e7\u00e3o para calcular o crc) Usa a transport.sendto para enviar cada bloco de bytes para o endere\u00e7o do equipamento e aguarda 0.5s para receber o ACK de resposta","title":"Fun\u00e7\u00e3o Arquivos"},{"location":"udp-server/#envio-de-sfb","text":"Pacotes de 520 bytes consecutivos s\u00e3o capturados do arquivo .SFB em que os primeiros 4 bytes s\u00e3o o endere\u00e7o de mem\u00f3ria e os \u00faltimos 4 bytes s\u00e3o o chksum dos dados. Sendo ent\u00e3o os pacotes a enviar para o dispositivo compostos da seguinte forma: Cabe\u00e7alho BINAVSFB (8 bytes) Dados SFB (520 bytes) N\u00famero de s\u00e9rie do equipamento (8 bytes) N\u00ba de mensagem (4 bytes) Chksum (4 bytes) async def Arquivos(self,transport,message,addr,device_id): sn = RSN_DICT[device_id] print(path_voz) for files in path_voz: f=open(f'{files}','rb') conteudo = f.read() separar = [conteudo[i:i+520]for i in range(0,len(conteudo),520)] print('\\n',files,'\\n') msg = '80000000' for i in range(len(separar)): bloco = cabe\u00e7alho.encode().hex()+separar[i].hex()+sn.encode().hex() sep = re.findall('........',bloco) sep.append(msg) cs = await self.crc(sep) bloc = bloco+msg+cs msg = int(msg,16)+1 msg = format(msg,'X') b = bytes.fromhex(bloc) transport.sendto(b, addr) await asyncio.sleep(0.5)","title":"Envio de SFB"},{"location":"udp-server/#funcao-crc","text":"Fun\u00e7\u00e3o que calcula o checksum de cada bloco de mensagem do protocolo SFB async def crc(self,x): cs_int = 0 sep = x for i in range(len(sep)): cs_int ^= (int(sep[i],16)) hexcs = hex(cs_int).replace('0x','') return hexcs","title":"Fun\u00e7\u00e3o crc"},{"location":"udp-server/#funcao-criar","text":"Fun\u00e7\u00e3o que faz o insert dos dados do equipamento no bando de dados coluna IMEI recebe device_id coluna SN recebe o SN do copiloto coluna VOZES recebe a quantidade de vozes embarcadas no equipamento async def criar(self,device_id): try: sn = RSN_DICT[device_id] cursor.execute('INSERT INTO vozes (\"IMEI\", \"SN\", \"VOZES\") \\ values (\\'{}\\', \\'{}\\', \\'{}\\');'.format(device_id, sn,self.vozes)) connection.commit() except: pass","title":"Fun\u00e7\u00e3o criar"},{"location":"udp-server/#funcao-fdir","text":"Envia o comando >FDIR< para o copiloto, no formato XVM utilizando a fun\u00e7\u00e3o generareXVM async def fdir(self,transport,addr,device_id): try: xvm = XVM.generateXVM(device_id,str(8010).zfill(4),'>FDIR<') print(xvm) transport.sendto(xvm.encode(), addr) if re.search('>.*EOF.*',self.message) is not None: fdir = re.search('>.*EOF.*',self.message) self.vozes = fdir.group().split('_')[2].split(':')[1] print('\\nFDIR:',self.vozes) return self.vozes except: raise Exception","title":"Fun\u00e7\u00e3o fdir"},{"location":"udp-server/#funcao-envioscript","text":"Le o conteudo do arquivo, que o diret\u00f3rio esta salvo na variavel path_script, filtra apenas os comandos, est\u00e3o entre >< Faz o envio dos comandos, no formato XVM e utilizando o transport.sendto async def envioScript(self,transport,addr,device_id): for i in path_script: with open(f'{i}') as f: self.tudo = f.read() self.comandos=(re.findall('(>.*<)', self.tudo)) for i in range(len(self.comandos)): try: xvm = XVM.generateXVM(device_id,str(8010+i).zfill(4),self.comandos[i]) transport.sendto(xvm.encode(),addr) await asyncio.sleep(0.3) except: raise Exception","title":"Fun\u00e7\u00e3o envioScript"},{"location":"udp-server/#funcao-main","text":"Fun\u00e7\u00e3o assincrona que cria um endpoint de datagrama, que recebe dois argumentos a fun\u00e7\u00e3o MyDatagramProtocol e o endere\u00e7o para vincular o servidor, no caso est\u00e1 no (0.0.0.0 na porta 10117) dentro do container, comentando, outros exemplos de ip e porta para utilizar async def main(): loop = asyncio.get_running_loop() transport, protocol = await loop.create_datagram_endpoint( lambda: MyDatagramProtocol(), local_addr=('0.0.0.0', 10117), family=socket.AF_INET) print(f\"Server started on {transport.get_extra_info('sockname')}\") try: while True: await asyncio.sleep(0.1) except asyncio.CancelledError: pass finally: transport.close()","title":"Fun\u00e7\u00e3o main"},{"location":"udp-server/#funcao-find","text":"Fun\u00e7\u00e3o que procura todos os arquivos dentro de um local, que \u00e9 passado como argumento (pasta). E os salva dentro da lista path def find(pasta): arquivos = os.listdir(pasta) for arquivo in arquivos: caminho_arquivo = os.path.join(pasta, arquivo) if os.path.isfile(caminho_arquivo): path.append(caminho_arquivo) return path","title":"Fun\u00e7\u00e3o find"},{"location":"udp-server/#inicializacao-do-script","text":"Faz um select no banco e coleta todos os device_id que j\u00e1 inseridos (ID), para se os mesmo enviarem mensagem para o servidor, n\u00e3o serem reconfigurados path_voz chama a fun\u00e7\u00e3o find e passa o caminho para os arquivos de voz, e a fun\u00e7\u00e3o retorna a lista dos arquivos dentro do diret\u00f3rio path_script chama a fun\u00e7\u00e3o find e passa o caminho para o script basico, e a fun\u00e7\u00e3o retorna a lista do arquivo dentro do diret\u00f3rio if __name__ == \"__main__\": try: cursor.execute('SELECT \"IMEI\" FROM vozes;') results = cursor.fetchall() ID = [result[0] for result in results] pasta_vozes = \"./app/Files/Vozes/\" pasta_scripts = \"./app/Files/Prod_script/\" path_voz = find(pasta_vozes) path = [] path_script = find(pasta_scripts) if path_voz: asyncio.run(main()) except KeyboardInterrupt: pass","title":"Inicializa\u00e7\u00e3o do Script"}]}